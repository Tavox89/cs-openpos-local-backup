<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>CSFX – Cierre diario</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body{font:14px system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:20px}
  header{display:flex;gap:10px;align-items:center;margin-bottom:14px;flex-wrap:wrap;justify-content:space-between}
  header .header-controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button{padding:8px 14px;border:0;border-radius:999px;font-weight:600;cursor:pointer;transition:transform .15s ease, box-shadow .15s ease;box-shadow:0 4px 12px rgba(0,0,0,.08)}
  button:hover{transform:translateY(-1px);box-shadow:0 6px 18px rgba(0,0,0,.12)}
  #open{background:#2563eb;color:#fff}
  #export{background:#0f9b69;color:#fff}
  #print{background:#374151;color:#fff}
  #verify-all{background:#f97316;color:#fff;box-shadow:0 6px 18px rgba(249,115,22,.24)}
  #verify-all[disabled]{opacity:.55;cursor:not-allowed;transform:none;box-shadow:none}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border:1px solid #ddd;padding:8px;text-align:left;vertical-align:top}
  th{background:#f5f5f5}
  .muted{opacity:.7}
  #orders{display:flex;flex-direction:column;gap:24px;margin-top:16px}
  .cashier-block{border:1px solid #ccc;border-radius:8px;padding:16px;background:#fff}
  .cashier-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap;gap:8px}
  .cashier-header h3{margin:0;font-size:16px}
  .list-table{width:100%;border-collapse:collapse;margin-top:8px}
  .list-table th,.list-table td{border:1px solid #e1e1e1;padding:6px 8px;font-size:13px}
  .list-table th{background:#fafafa;text-transform:uppercase;font-size:11px;letter-spacing:.04em}
  .status-pill{display:inline-flex;align-items:center;padding:2px 10px;border-radius:999px;font-size:12px;text-transform:capitalize;border:1px solid rgba(244,191,64,.45);background:#fff8e1;color:#9c6b00}
  .status-pill.pending{background:#fff8e1;color:#9c6b00;border-color:rgba(244,191,64,.45)}
  .status-pill.verificado{background:#e6f9ee;color:#0b8c52;border-color:rgba(25,135,84,.35)}
  .status-pill.warning{background:#fff7ed;color:#c2410c;border-color:rgba(251,146,60,.35)}
  .status-pill.mismatch{background:#fee2e2;color:#b91c1c;border-color:rgba(220,38,38,.3)}
  .status-pill.missing{background:#fef3c7;color:#92400e;border-color:rgba(217,119,6,.35)}
  .status-pill.loading{background:#e0f2fe;color:#0369a1;border-color:rgba(3,105,161,.35)}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;background:#eef;border-radius:999px;font-size:12px;color:#334}
  .laybuy-pill{display:inline-flex;align-items:center;margin-left:6px;padding:2px 8px;border-radius:999px;background:#fef3c7;border:1px solid rgba(217,119,6,.4);color:#92400e;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.04em}
  .cashier-summary{margin-top:8px;padding:6px 12px;background:#f4f8ff;border-radius:8px;font-size:13px;color:#264a8a;display:flex;flex-wrap:wrap;gap:8px}
  .cashier-summary strong{font-size:11px;text-transform:uppercase;letter-spacing:.08em;color:#1e3a8a}
  .summary-grid{display:flex;flex-wrap:wrap;gap:12px;margin-bottom:12px}
  .summary-card{flex:1 1 180px;background:#111;color:#fff;border-radius:12px;padding:12px 16px;box-shadow:0 10px 25px rgba(0,0,0,.25)}
  .summary-label{display:block;font-size:12px;opacity:.7;text-transform:uppercase;letter-spacing:.08em}
  .summary-value{display:flex;flex-wrap:wrap;gap:6px;font-size:20px;margin:6px 0;font-weight:600;align-items:baseline}
  .summary-value > span{display:inline-block}
  .summary-digit{font-size:28px}
  .summary-hint{display:block;font-size:12px;opacity:.6}
  .summary-bar{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;background:#f9fbff;border:1px solid #e0e8ff;border-radius:10px;padding:10px 14px;margin-bottom:16px}
  .summary-bar > div{font-size:13px;color:#264a8a;display:flex;flex-wrap:wrap;gap:6px;align-items:center}
  .summary-bar > div > strong{margin-right:6px}
  .summary-chip{display:inline-block;background:#fff;color:#111;padding:2px 10px;border-radius:999px;font-size:12px;margin:2px 4px 2px 0;border:1px solid rgba(17,24,39,.08)}
  .payments-wrap{display:flex;flex-wrap:wrap;gap:6px}
  .payments-summary{display:flex;flex-wrap:wrap;gap:6px}
  .pay-pill{display:inline-flex;align-items:center;background:#eef;padding:4px 10px;border-radius:999px;margin:0;font-size:12px;line-height:1.3;border:1px solid rgba(99,102,241,.2)}
  .pay-pill strong{font-weight:600;margin-right:6px}
  .pay-pill span{display:block;color:#1f2937;font-weight:500}
  .pay-pill small{display:block;font-size:11px;color:#334;opacity:.75;margin-left:4px}
  .action-btn{padding:6px 12px;border:0;border-radius:999px;background:#2563eb;color:#fff;cursor:pointer;font-size:12px;box-shadow:0 4px 12px rgba(37,99,235,.2);transition:transform .15s ease, box-shadow .15s ease}
  .action-btn:hover{transform:translateY(-1px);box-shadow:0 6px 18px rgba(37,99,235,.24)}
  .action-btn.btn-view{background:#0ea5e9}
  .action-btn.btn-verify{background:#f59e0b}
  .action-btn.btn-verify:hover{box-shadow:0 6px 18px rgba(245,158,11,.24)}
  .action-btn.btn-view:hover{box-shadow:0 6px 18px rgba(14,165,233,.24)}
  .actions-cell{display:flex;flex-direction:column;gap:6px;align-items:flex-start}
  .info-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px}
  .info-card{background:#f7f9ff;border-radius:10px;padding:10px 12px;box-shadow:0 1px 3px rgba(15,23,42,.08)}
  .info-label{display:block;font-size:11px;text-transform:uppercase;letter-spacing:.08em;color:#64748b;margin-bottom:6px}
  .info-value{font-size:14px;font-weight:600;color:#0f172a}
  .status-block{margin-top:6px;font-size:12px;color:#6b7280}
  .status-block a{color:#2563eb;text-decoration:none;font-weight:600}
  .status-block a:hover{text-decoration:underline}
  .status-notes{margin:4px 0 0;padding-left:18px;color:#6b7280}
  .status-notes li{margin:2px 0;list-style:disc}
  .status-error{color:#b91c1c;font-weight:600;font-size:12px;margin-top:6px}
  .raw-block{margin-top:8px;background:#0f172a;color:#f8fafc;border-radius:10px;overflow:hidden}
  .raw-block summary{cursor:pointer;padding:10px 14px;background:#1e293b;color:#fff;font-weight:600;outline:none}
  .raw-block[open]{box-shadow:0 10px 25px rgba(15,23,42,.3)}
  .raw-block pre{margin:0;padding:12px 16px;font-size:12px;background:#0f172a;color:#e2e8f0;max-height:260px;overflow:auto}
  #detail{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.45)}
  #detail[hidden]{display:none}
  .detail-card{background:#fff;width:min(90vw,900px);max-height:90vh;border-radius:10px;overflow:auto;box-shadow:0 12px 40px rgba(0,0,0,.35);display:flex;flex-direction:column}
  .detail-card header{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid #eee;background:#111;color:#fff}
  .detail-card h2{margin:0;font-size:18px}
  #detail-close{border:0;background:transparent;font-size:22px;line-height:1;cursor:pointer;color:#f5f5f5}
  #detail-close:hover{color:#93c5fd}
  .detail-content{padding:16px;display:flex;flex-direction:column;gap:16px}
  .detail-content section{background:#f8fafc;border:1px solid #e2e8ff;border-radius:12px;padding:12px}
  .detail-content h3{margin:0 0 8px;font-size:14px;color:#1e293b;text-transform:uppercase;letter-spacing:.06em}
  .detail-content table{width:100%;border-collapse:collapse}
  .detail-content table th,.detail-content table td{border:1px solid #e2e8ff;padding:6px 8px;font-size:13px}
  .detail-content table th{background:#eef2ff;text-transform:uppercase;font-size:11px;letter-spacing:.06em;color:#1e293b}
  #detail-totals{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px;font-size:13px;margin-top:6px}
  #detail-totals dt{font-weight:600;font-size:11px;text-transform:uppercase;color:#64748b}
  #detail-totals dd{margin:4px 0 0;color:#0f172a;font-weight:600;font-size:14px}
  #detail-verify-section{margin-bottom:16px}
  #detail-verify{border-radius:10px;padding:12px;font-size:13px;line-height:1.4}
  #detail-verify.is-ok{background:#ecfdf5;border:1px solid rgba(16,185,129,.35);color:#047857}
  #detail-verify.is-warning{background:#fff7ed;border:1px solid rgba(251,146,60,.35);color:#c2410c}
  #detail-verify.is-error{background:#fef2f2;border:1px solid rgba(239,68,68,.35);color:#b91c1c}
  #detail-verify.is-missing{background:#fff7ed;border:1px solid rgba(217,119,6,.35);color:#92400e}
  #detail-verify .verify-label{font-weight:600;margin-bottom:4px;font-size:14px}
  #detail-verify ul{margin:6px 0 0;padding-left:18px}
</style>
</head>
<body>
<header>
  <div class="header-controls">
    <button id="open">Seleccionar carpeta (día)</button>
    <button id="export" disabled>Descargar CSV</button>
    <button id="print" disabled>Imprimir</button>
    <span id="info" class="muted"></span>
  </div>
  <button id="verify-all" class="action-btn action-verify-all" disabled>Verificación general</button>
</header>

<section id="summary"></section>
<section id="orders"></section>

<div id="detail" hidden>
  <div class="detail-backdrop"></div>
  <div class="detail-card" role="dialog" aria-modal="true">
    <header>
      <h2>Detalle del pedido</h2>
      <button type="button" id="detail-close" aria-label="Cerrar">×</button>
    </header>
    <div class="detail-content">
      <section>
        <h3>Información general</h3>
        <div id="detail-info" class="info-grid"></div>
      </section>
      <section id="detail-verify-section" hidden>
        <h3>Verificación</h3>
        <div id="detail-verify"></div>
      </section>
      <section>
        <h3>Productos</h3>
        <table id="detail-items"><thead><tr><th>Producto</th><th>Código</th><th>Cantidad</th><th>Precio</th><th>Descuento</th><th>Total</th></tr></thead><tbody></tbody></table>
      </section>
      <section>
        <h3>Pagos</h3>
        <table id="detail-payments"><thead><tr><th>Método</th><th>Monto</th><th>Vuelto</th><th>Referencia</th><th>Tipo</th></tr></thead><tbody></tbody></table>
      </section>
      <section>
        <h3>Totales</h3>
        <dl id="detail-totals"></dl>
      </section>
      <details class="raw-block">
        <summary>Datos crudos</summary>
        <pre id="detail-raw"></pre>
      </details>
    </div>
  </div>
</div>

<script>
(async function(){
  const $ = s=>document.querySelector(s);
  let folder=null;
  let orders=[];
  const fileHandleMap = new Map();
  let currentDetailOrderId = null;
  const EMBED_CONTEXT = window.CSFX_LB_EMBED_CONTEXT || null;
  const REST_BASE = (EMBED_CONTEXT && EMBED_CONTEXT.restRoot) ? EMBED_CONTEXT.restRoot.replace(/\/$/,'') : `${window.location.origin}/wp-json/csfx-lb/v1`;
  const restContext = {
    nonce: EMBED_CONTEXT && EMBED_CONTEXT.nonce ? EMBED_CONTEXT.nonce : null,
    user: EMBED_CONTEXT && EMBED_CONTEXT.user ? EMBED_CONTEXT.user : null,
    loading: false
  };
  let restContextPromise = null;
  let verifyAllRunning = false;
  const SIGNATURE_SECRET_PRIMARY = EMBED_CONTEXT && EMBED_CONTEXT.signature_secret ? EMBED_CONTEXT.signature_secret : '';
  const SIGNATURE_SECRET_LEGACY = EMBED_CONTEXT && EMBED_CONTEXT.signature_secret_legacy ? EMBED_CONTEXT.signature_secret_legacy : '';
  const SIGNATURE_SECRET_POOL_RAW = EMBED_CONTEXT && Array.isArray(EMBED_CONTEXT.signature_secret_pool)
    ? EMBED_CONTEXT.signature_secret_pool
    : [];
  const SIGNATURE_SECRET_POOL = (() => {
    const list = [];
    if (SIGNATURE_SECRET_PRIMARY) list.push(SIGNATURE_SECRET_PRIMARY);
    SIGNATURE_SECRET_POOL_RAW.forEach(value => {
      if (typeof value === 'string' && value.length && !list.includes(value)) {
        list.push(value);
      }
    });
    if (SIGNATURE_SECRET_LEGACY && !list.includes(SIGNATURE_SECRET_LEGACY)) {
      list.push(SIGNATURE_SECRET_LEGACY);
    }
    return list;
  })();
  const SIGNATURE_SECRET = SIGNATURE_SECRET_POOL.length ? SIGNATURE_SECRET_POOL[0] : SIGNATURE_SECRET_PRIMARY;
  const WEB_CRYPTO_AVAILABLE = Boolean(window.crypto && window.crypto.subtle && typeof TextEncoder !== 'undefined');
  const cryptoTextEncoder = WEB_CRYPTO_AVAILABLE ? new TextEncoder() : null;
  const signatureKeyCache = new Map();
  const hexFromBuffer = buffer => Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2,'0')).join('');

  function timingSafeEqualHex(a,b){
    if (typeof a !== 'string' || typeof b !== 'string') return false;
    if (a.length !== b.length) return false;
    let result = 0;
    for (let i=0;i<a.length;i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return result === 0;
  }

  function canonicalizeSignatureSource(value){
    if (Array.isArray(value)) return value.map(canonicalizeSignatureSource);
    if (value && typeof value === 'object') {
      const out={};
      const keys = Object.keys(value).filter(k => k !== 'signature').sort();
      for (const key of keys){ out[key] = canonicalizeSignatureSource(value[key]); }
      return out;
    }
    return value;
  }

  async function getViewerSignatureKey(secret, cacheKey){
    if (!WEB_CRYPTO_AVAILABLE || !secret) return null;
    if (signatureKeyCache.has(cacheKey)) {
      return signatureKeyCache.get(cacheKey);
    }
    const promise = crypto.subtle.importKey(
      'raw',
      cryptoTextEncoder.encode(secret),
      { name:'HMAC', hash:'SHA-256' },
      false,
      ['sign']
    ).catch(()=>null);
    signatureKeyCache.set(cacheKey, promise);
    return promise;
  }

  async function verifyDocSignature(doc){
    if (!doc || typeof doc !== 'object') return { status: 'missing' };
    const sigNode = doc.signature;
    const signature = sigNode && typeof sigNode === 'object' ? sigNode.value : sigNode;
    if (!signature || typeof signature !== 'string') return { status: 'missing' };
    if (!WEB_CRYPTO_AVAILABLE) return { status: 'unchecked' };

    const pool = SIGNATURE_SECRET_POOL.length
      ? SIGNATURE_SECRET_POOL
      : (SIGNATURE_SECRET ? [SIGNATURE_SECRET] : []);
    let canonical = null;
    let canonicalJson = '';
    const expectedMap = {};

    for (let index = 0; index < pool.length; index++) {
      const secret = pool[index];
      const key = await getViewerSignatureKey(secret, `pool_${index}`);
      if (!key) continue;
      if (!canonical) {
        canonical = canonicalizeSignatureSource(doc);
        canonicalJson = JSON.stringify(canonical);
      }
      const sigBuffer = await crypto.subtle.sign('HMAC', key, cryptoTextEncoder.encode(canonicalJson));
      const expected = hexFromBuffer(sigBuffer);
      expectedMap[`secret_${index}`] = expected;
      if (timingSafeEqualHex(expected, signature)) {
        return { status: index === 0 ? 'valid' : 'valid_legacy', source: index === 0 ? 'primary' : `legacy_${index}` };
      }
    }

    console.warn('[CSFX][Signature] mismatch', { provided: signature, expectedMap, canonicalJson });
    return { status: 'invalid', canonicalJson, provided: signature, expected: expectedMap, pool: pool.length };
  }

  async function signDocSignature(doc){
    const secret = SIGNATURE_SECRET_POOL.length ? SIGNATURE_SECRET_POOL[0] : SIGNATURE_SECRET;
    if (!WEB_CRYPTO_AVAILABLE || !secret || !doc || typeof doc !== 'object') return null;
    const key = await getViewerSignatureKey(secret, 'primary');
    if (!key) return null;
    const canonical = canonicalizeSignatureSource(doc);
    const canonicalJson = JSON.stringify(canonical);
    const sigBuffer = await crypto.subtle.sign('HMAC', key, cryptoTextEncoder.encode(canonicalJson));
    const signature = hexFromBuffer(sigBuffer);
    doc.signature = { value: signature, alg: 'HS256', ts: Date.now() };
    return signature;
  }

  function signatureStatusLabel(status){
    switch (status) {
      case 'valid':
        return 'Firma válida';
      case 'invalid':
        return 'Firma inválida';
      case 'missing':
        return WEB_CRYPTO_AVAILABLE ? 'Sin firma' : 'No disponible';
      case 'unchecked':
        return 'Sin validar (navegador)';
      default:
        return 'Desconocida';
    }
  }

  const VERIFICATION_LABELS = {
    pending: { label: 'Sin sinc.', pill: 'pending' },
    loading: { label: 'Verificando…', pill: 'loading' },
    verified: { label: 'Verificado', pill: 'verificado' },
    verified_with_warnings: { label: 'Verificado con advertencias', pill: 'warning' },
    mismatch: { label: 'Con diferencias', pill: 'mismatch' },
    missing: { label: 'Pedido no encontrado', pill: 'missing' },
    error: { label: 'Error de verificación', pill: 'mismatch' }
  };
  const VERIFICATION_SUMMARY_TITLES = {
    pending: 'Sin sinc.',
    loading: 'Verificando',
    verified: 'Verificado',
    verified_with_warnings: 'Verificado con advertencias',
    mismatch: 'Con diferencias',
    missing: 'No encontrado',
    error: 'Errores'
  };

  function sanitizeDisplayText(value){
    if (value == null) return '';
    const text = String(value).trim();
    if (!text) return '';
    if (text.length > 200) return '';
    if (/\r|\n/.test(text)) return '';
    if (text.includes('<') || text.includes('>')) return '';
    if (/^const\s/.test(text) || /^function\s/.test(text) || /^class\s/.test(text)) return '';
    return text;
  }

  function alertFriendly(err, fallback){
    if (err) {
      console.warn('[CSFX][Verify]', err);
    }
    alert(fallback);
  }

  async function ensureRestContext(force = false){
    if (!force && restContext.nonce) {
      return restContext;
    }
    if (restContextPromise) {
      return restContextPromise;
    }
    restContext.loading = true;
    restContextPromise = fetch(`${REST_BASE}/context`, {
      credentials: 'include'
    })
      .then(async response => {
        if (!response.ok) {
          const status = response.status;
          const text = await response.text().catch(()=> '');
          let message = 'No se pudo preparar la verificación.';
          if (status === 401 || status === 403) {
            message = 'Permiso denegado. Inicia sesión en WordPress con acceso a WooCommerce.';
          } else if (status === 404) {
            message = 'Servicio de verificación no encontrado. Verifica que el plugin esté activo.';
          } else if (text) {
            console.warn('[CSFX][Verify][context] respuesta inesperada', text.slice(0, 200));
          }
          throw new Error(message);
        }
        return response.json();
      })
      .then(data => {
        restContext.nonce = data && data.nonce ? data.nonce : null;
        restContext.user = data && data.user ? data.user : null;
        return restContext;
      })
      .catch(err => {
        restContext.nonce = null;
        throw err;
      })
      .finally(() => {
        restContext.loading = false;
        restContextPromise = null;
      });
    return restContextPromise;
  }

  const toAmount = value => {
    if (value == null || value === '') return 0;
    if (typeof value === 'number') return value;
    if (typeof value === 'string') {
      const normalized = value.replace(/[^0-9,.-]/g, '').replace(',', '.');
      const num = parseFloat(normalized);
      return isNaN(num) ? 0 : num;
    }
    const num = Number(value);
    return isNaN(num) ? 0 : num;
  };

  const fmtMoney = (amount, formatted) => {
    if (formatted && formatted.trim) return formatted.trim();
    if (amount == null || amount === '') return '';
    const num = Number(amount);
    return isNaN(num) ? String(amount) : num.toLocaleString('es-VE', {minimumFractionDigits:2, maximumFractionDigits:2});
  };

  let DEFAULT_CASHIER = '';
  try {
    DEFAULT_CASHIER = (localStorage.getItem('csfx_lb_staff_login') || '').trim();
  } catch (err) {
    DEFAULT_CASHIER = '';
  }

  function normalizeCashierName(name, registerName) {
    const candidate = (name || '').toString().trim();
    const register = (registerName || '').toString().trim();
    if (candidate && register && candidate.toLowerCase() === register.toLowerCase()) {
      return DEFAULT_CASHIER || candidate;
    }
    if (!candidate) {
      return DEFAULT_CASHIER || register || 'Sin cajero';
    }
    return candidate;
  }

  function safe(value){
    if (value == null || value === '') return '—';
    return String(value);
  }

  function paymentsFrom(orderData, rawDoc){
    const map = new Map();

    const upsert = (codeRaw, labelRaw)=>{
      const key = (codeRaw || labelRaw || 'pago').toString().toLowerCase();
      if (!map.has(key)) {
        map.set(key, {
          code: codeRaw || labelRaw || key,
          label: labelRaw || codeRaw || 'Pago',
          amount: 0,
          display: '0,00',
          change: 0,
          changeDisplay: '0,00',
          reference: '',
          type: ''
        });
      }
      return map.get(key);
    };

    const applyPayment = (p)=>{
      if(!p) return;
      const code = p.code || p.payment_code || p.method || p.payment_name || p.name || p.title || '';
      const label = p.name || p.payment_name || p.method || p.title || code || 'Pago';
      const amount = toAmount(p.paid ?? p.total ?? p.amount ?? p.in_amount ?? p.paid_amount ?? 0);
      const change = toAmount(p.change ?? p.return ?? p.change_amount ?? p.return_amount ?? 0);
      const formatted = p.paid_currency_formatted || p.total_currency_formatted || p.amount_currency_formatted || p.in_amount_currency_formatted;
      const entry = upsert(code, label);
      entry.amount += amount;
      entry.change += change;
      entry.display = fmtMoney(entry.amount);
      entry.changeDisplay = fmtMoney(entry.change);
      if (!entry.reference && (p.payment_ref || p.ref || p.reference || p.transaction_reference)) {
        entry.reference = p.payment_ref || p.ref || p.reference || p.transaction_reference || '';
      }
      if (!entry.type && (p.type || p.offline_transaction || p.mode || p.transaction_type)) {
        entry.type = p.type || p.offline_transaction || p.mode || p.transaction_type || '';
      }
    };

    if (Array.isArray(orderData?.payment_method)) {
      orderData.payment_method.forEach(applyPayment);
    }
    if (Array.isArray(rawDoc?.payments)) {
      rawDoc.payments.forEach(applyPayment);
    }

    const trans = orderData?.transactions;
    const mergeTransaction = (p)=>{
      if(!p) return;
      applyPayment(p);
    };
    if (Array.isArray(trans)) trans.forEach(mergeTransaction);
    else if (trans && typeof trans === 'object') {
      Object.values(trans).forEach(mergeTransaction);
    }

    return [...map.values()];
  }

  function getCustomerName(orderData, docCustomer){
    const fromOrder = orderData?.customer;
    const candidates = [
      fromOrder?.name,
      [fromOrder?.firstname, fromOrder?.lastname].filter(Boolean).join(' ').trim(),
      docCustomer?.name,
      [docCustomer?.firstname, docCustomer?.lastname].filter(Boolean).join(' ').trim()
    ].filter(v=>v && v.length);
    return candidates[0] || 'Sin cliente';
  }

  function normalizeOrder(doc, signatureResult){
    const orderData = doc.orderData || {};
    const registerName = orderData.register?.name || doc.registerName || '—';
    const signatureInfo = signatureResult || { status: WEB_CRYPTO_AVAILABLE ? 'missing' : 'unchecked' };
    const signatureStatus = signatureInfo && signatureInfo.status ? signatureInfo.status : (WEB_CRYPTO_AVAILABLE ? 'missing' : 'unchecked');
    let cashier =
      orderData.user?.username ||
      orderData.user?.user_login ||
      orderData.sale_person_username ||
      orderData.sale_person_name ||
      orderData.salesperson ||
      orderData.cashier ||
      doc.cashier ||
      doc.cart?.cashier ||
      doc.cart?.salesperson ||
      '';
    cashier = normalizeCashierName(cashier, registerName);
    const orderNumber = doc.orderNumber || orderData.order_number || orderData.order_number_format || (orderData.order_number_details && orderData.order_number_details.order_number) || doc.key;
    const orderId = doc.orderId || orderData.order_id || orderData.id || null;
    const rawTotals = doc.totals || orderData.totals || {};
    const totalsData = rawTotals && typeof rawTotals === 'object' ? {...rawTotals} : {};
    if (rawTotals && typeof rawTotals === 'object' && rawTotals.currency) {
      totalsData.currency = {...rawTotals.currency};
    }
    const remainPaid = toAmount(
      (totalsData && totalsData.remain_paid != null ? totalsData.remain_paid : null)
        ?? (rawTotals && rawTotals.remain_paid != null ? rawTotals.remain_paid : null)
        ?? (rawTotals && rawTotals.remain != null ? rawTotals.remain : null)
        ?? (orderData && orderData.totals && orderData.totals.remain_paid != null ? orderData.totals.remain_paid : null)
        ?? (doc?.totals?.remain_paid ?? doc?.totals?.remain ?? 0)
    );
    totalsData.remain_paid = remainPaid;
    const laybuyPending = remainPaid > 0.01;
    const cartItems = Array.isArray(orderData?.items)
      ? orderData.items
      : Array.isArray(doc?.cart?.items)
        ? doc.cart.items
        : Array.isArray(doc?.cart)
          ? doc.cart
          : [];
    const payments = paymentsFrom(orderData, doc);
    const discountFromItems = cartItems.reduce((acc,it)=>{
      const value = toAmount(it.final_discount_amount ?? it.discount_amount ?? it.discount ?? 0);
      return acc + value;
    },0);
    if (totalsData.discount_amount == null) {
      totalsData.discount_amount =
        orderData.total_discount ??
        orderData.discount_amount ??
        (discountFromItems || null);
    }
    if (totalsData.currency) {
      if (!totalsData.currency.discount_amount && totalsData.discount_amount != null) {
        totalsData.currency.discount_amount = fmtMoney(totalsData.discount_amount);
      }
    }
    let totalValue = totalsData?.grand_total ?? orderData.grand_total ?? totalsData?.total ?? orderData.total_paid ?? 0;
    if (!totalValue) {
      const paySum = Array.isArray(payments) ? payments.reduce((acc, p) => acc + (Number(p.amount) || 0), 0) : 0;
      if (paySum > 0) {
        totalValue = paySum;
      } else {
        const list = Array.isArray(orderData?.items)
          ? orderData.items
          : (Array.isArray(doc?.cart) ? doc.cart : (Array.isArray(doc?.cart?.items) ? doc.cart.items : []));
        if (list.length) {
          totalValue = list.reduce((acc, it) => acc + (Number(it.total ?? it.total_incl_tax ?? it.final_price ?? it.price) || 0), 0);
        }
      }
    }
    const total = toAmount(totalValue);
    const totalDisplay = totalsData?.currency?.grand_total
      || orderData.grand_total_currency_formatted
      || totalsData?.currency?.total_paid
      || orderData.total_paid_currency_formatted
      || fmtMoney(total);
    const discountValue = orderData.total_discount ?? orderData.discount_amount ?? totalsData?.discount_amount ?? 0;
    const discountAmount = toAmount(discountValue);
    const discountDisplay = orderData.total_discount_currency_formatted || orderData.discount_amount_currency_formatted || totalsData?.currency?.discount || fmtMoney(discountAmount);
    const customerName = getCustomerName(orderData, doc.customer);

    const createdAtCandidates = [
      doc.createdAtText,
      orderData.created_at_utc,
      orderData.created_at,
      doc.createdAt,
      orderData.created_at_ms,
      orderData.updated_at
    ];

    let createdAtDate = null;
    for (const candidate of createdAtCandidates) {
      if (candidate === undefined || candidate === null || candidate === '') continue;
      let date;
      if (candidate instanceof Date) {
        date = candidate;
      } else if (typeof candidate === 'number') {
        date = new Date(candidate);
      } else if (typeof candidate === 'string' && /^\d+$/.test(candidate)) {
        date = new Date(Number(candidate));
      } else {
        date = new Date(candidate);
      }
      if (date && !isNaN(date.getTime())) {
        createdAtDate = date;
        break;
      }
    }
    if (!createdAtDate && doc.createdAtParts) {
      const p = doc.createdAtParts;
      const iso = `${p.y || '1970'}-${p.m || '01'}-${p.d || '01'}T${p.H || '00'}:${p.M || '00'}:${p.S || '00'}Z`;
      const date = new Date(iso);
      if (!isNaN(date.getTime())) createdAtDate = date;
    }

    const createdAtISO = createdAtDate ? createdAtDate.toISOString() : (doc.createdAtText || orderData.created_at_utc || '');
    const createdAtDisplay = createdAtDate ? createdAtDate.toLocaleString('es-VE', { hour12: true }) : (createdAtISO || '—');
    const createdAtTime = createdAtDate ? createdAtDate.toLocaleTimeString('es-VE', {
      hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true
    }) : '—';

    const status = (doc.status || orderData.status || 'pending').toString();
    return {
      id: `${doc.ref || doc.key}`,
      fileName: doc.fileName,
      cashier,
      orderNumber,
      orderId,
      total,
      totalDisplay,
      discountAmount,
      discountDisplay,
      payments,
      customerName,
      createdAtISO,
      createdAtDisplay,
      createdAtTime,
      status,
      doc,
      orderData,
      registerName,
      createdAtParts: doc.createdAtParts || {},
      totals: totalsData,
      docStatus: status,
      signatureResult: signatureInfo,
      signatureStatus,
      verification: null,
      verificationError: null,
      verificationLoading: false,
      laybuyPending
    };
  }

  function buildSummary(){
    const overall = {orders: orders.length, total:0, discount:0};
    const byCashier = new Map();
    const byMethod = new Map();
    const byStatus = new Map();
    orders.forEach(o=>{
      overall.total += toAmount(o.total);
      overall.discount += toAmount(o.discountAmount);
      if(!byCashier.has(o.cashier)) byCashier.set(o.cashier,{total:0,count:0});
      const info = byCashier.get(o.cashier);
      info.total += toAmount(o.total);
      info.count++;
      const statusKey = getVerificationMeta(o).status || 'pending';
      byStatus.set(statusKey, (byStatus.get(statusKey) || 0) + 1);
      o.payments.forEach(p=>{
        const key = p.label || 'Pago';
        const bucket = byMethod.get(key) || { amount: 0, change: 0 };
        bucket.amount += toAmount(p.amount);
        bucket.change += toAmount(p.change);
        byMethod.set(key, bucket);
      });
    });

    const cashierChips = [...byCashier.entries()].map(([name,val])=>`<span class="summary-chip">${name}: ${fmtMoney(val.total)} (${val.count})</span>`).join('') || '<span class="summary-chip">—</span>';
    const methodChips = [...byMethod.entries()].map(([m,v])=>`<span class="summary-chip">${m}: ${fmtMoney(v.amount)}${v.change > 0 ? ` (Vuelto: ${fmtMoney(v.change)})` : ''}</span>`).join('') || '<span class="summary-chip">—</span>';
    const statusChips = overall.orders ? [...byStatus.entries()].map(([s,c])=>{
      const label = VERIFICATION_SUMMARY_TITLES[s] || s;
      return `<span class="summary-chip">${c} ${label}</span>`;
    }).join('') : '<span class="summary-chip">—</span>';

    $('#summary').innerHTML = `
      <div class="summary-grid">
        <div class="summary-card">
          <span class="summary-label">Órdenes</span>
          <span class="summary-value"><span class="summary-digit">${overall.orders}</span></span>
          <span class="summary-hint">Total ${fmtMoney(overall.total)}</span>
        </div>
        <div class="summary-card">
          <span class="summary-label">Descuento</span>
          <span class="summary-value"><span class="summary-digit">${fmtMoney(overall.discount)}</span></span>
          <span class="summary-hint">Aplicado</span>
        </div>
        <div class="summary-card">
          <span class="summary-label">Status</span>
          <span class="summary-value">${statusChips}</span>
        </div>
      </div>
      <div class="summary-bar">
        <div><strong>Por cajero:</strong> ${cashierChips}</div>
        <div><strong>Por método:</strong> ${methodChips}</div>
      </div>`;

    $('#export').disabled = orders.length===0;
    $('#print').disabled = orders.length===0;
    const verifyAllBtn = $('#verify-all');
    if (verifyAllBtn) {
      verifyAllBtn.disabled = orders.length===0 || verifyAllRunning;
      verifyAllBtn.textContent = verifyAllRunning ? 'Verificando…' : 'Verificación general';
    }
  }

  function applySignatureMeta(meta, order){
    if (!order) return meta;
    const status = order.signatureStatus;
    if (!status || status === 'valid') return meta;
    const adjusted = { ...meta };
    const warnings = Array.isArray(adjusted.warnings) ? [...adjusted.warnings] : [];
    if (status === 'invalid') {
      const warning = 'Firma HMAC inválida: el contenido no coincide con la firma almacenada.';
      warnings.unshift(warning);
      const canOverrideStatus = adjusted.status !== 'missing' && adjusted.status !== 'pending';
      if (canOverrideStatus) {
        adjusted.status = 'mismatch';
        adjusted.pill = VERIFICATION_LABELS.mismatch.pill;
        if (!adjusted.label || adjusted.label === VERIFICATION_LABELS.pending.label) {
          adjusted.label = 'Archivo alterado';
        }
      }
      if (!adjusted.message) adjusted.message = warning;
      warnings.unshift('Puedes usar “Re-firmar” para regenerar la firma con la clave actual.');
    } else if (status === 'missing') {
      warnings.unshift('Sin firma HMAC (respaldo anterior o manipulado).');
    } else if (status === 'unchecked') {
      warnings.unshift('No se pudo validar la firma HMAC en este navegador.');
    }
    adjusted.warnings = warnings;
    adjusted.signature = status;
    return adjusted;
  }

  function getVerificationMeta(order){
    let meta;
    if (!order) {
      meta = { status: 'pending', label: VERIFICATION_LABELS.pending.label, pill: VERIFICATION_LABELS.pending.pill, warnings: [], differences: [], message: '' };
    } else if (order.verificationLoading) {
      meta = { status: 'loading', label: VERIFICATION_LABELS.loading.label, pill: VERIFICATION_LABELS.loading.pill, warnings: [], differences: [], message: '' };
    } else if (order.verification && order.verification.status) {
      const base = VERIFICATION_LABELS[order.verification.status] || VERIFICATION_LABELS.pending;
      const warnings = Array.isArray(order.verification.warnings)
        ? order.verification.warnings.map(sanitizeDisplayText).filter(Boolean)
        : [];
      if (Array.isArray(order.verification.duplicates) && order.verification.duplicates.length) {
        order.verification.duplicates.forEach(name => {
          const text = sanitizeDisplayText(name);
          if (text) warnings.push(`Duplicación detectada: ${text}`);
        });
      }
      let message = sanitizeDisplayText(order.verification.message);
      if (order.verification.status === 'missing' && !message) {
        warnings.push('Pedido no encontrado en WooCommerce.');
      }
      if (order.verification.created_order) {
        warnings.push('Pedido creado automáticamente durante el resync.');
      }
      meta = {
        status: order.verification.status,
        label: base.label,
        pill: base.pill,
        warnings,
        differences: Array.isArray(order.verification.differences)
          ? order.verification.differences.map(sanitizeDisplayText).filter(Boolean)
          : [],
        message,
        adminUrl: order.verification.adminUrl || '',
        noteAdded: !!order.verification.note_added,
        resync: !!order.verification.resync,
        resyncNote: !!order.verification.resync_note
      };
    } else if (order.verificationError) {
      const message = sanitizeDisplayText(order.verificationError) || 'Error de verificación';
      meta = { status: 'error', label: VERIFICATION_LABELS.error.label, pill: VERIFICATION_LABELS.error.pill, warnings: [], differences: [], message };
    } else {
      meta = { status: 'pending', label: VERIFICATION_LABELS.pending.label, pill: VERIFICATION_LABELS.pending.pill, warnings: [], differences: [], message: '' };
    }
    return applySignatureMeta(meta, order);
  }

  function renderNoteList(list, cssClass = 'status-notes'){
    if (!Array.isArray(list) || !list.length) return '';
    const items = list.map(sanitizeDisplayText).filter(Boolean);
    if (!items.length) return '';
    return `<ul class="${cssClass}">${items.map(item => `<li>${safe(item)}</li>`).join('')}</ul>`;
  }

  function buildStatusHtml(order){
    const meta = getVerificationMeta(order);
    const pieces = [`<span class="status-pill ${meta.pill || 'pending'}">${safe(meta.label)}</span>`];
    if (meta.message) {
      pieces.push(`<div class="status-block">${safe(meta.message)}</div>`);
    }
    if (Array.isArray(meta.differences) && meta.differences.length) {
      pieces.push(renderNoteList(meta.differences));
    }
    if (Array.isArray(meta.warnings) && meta.warnings.length) {
      pieces.push(renderNoteList(meta.warnings));
    }
    if (order && order.verification && order.verification.note_added) {
      pieces.push('<div class="status-block muted">Nota agregada en WooCommerce</div>');
    }
    if (order && order.verification && order.verification.resync_note) {
      pieces.push('<div class="status-block muted">Resync registrado en WooCommerce</div>');
    }
  if (meta.adminUrl) {
    pieces.push(`<div class="status-block"><a href="${meta.adminUrl}" target="_blank" rel="noopener">Abrir en WooCommerce</a></div>`);
  }
  return pieces.join('');
}

  async function ensureValidSignatureForOrder(order){
    if (!order) return;
    const status = order.signatureStatus;
    if (!status || status === 'valid' || status === 'unchecked') return;
    const payloadSource = order.sourceDoc || order.doc || null;
    if (!payloadSource) return;
    try {
      const normalized = JSON.parse(JSON.stringify(payloadSource));
      const server = await requestServerSignature(normalized);
      if (server && server.doc && server.signature) {
        order.doc = server.doc;
        order.sourceDoc = server.doc;
        order.signatureResult = { status: 'valid', source: 'server' };
        order.signatureStatus = 'valid';
      }
    } catch (err) {
      console.warn('[CSFX][Signature] no se pudo regenerar firma previa', order.orderNumber || order.fileName, err);
    }
  }

  async function performVerification(order, mode = 'verify'){
    if (!order || order.verificationLoading) return;

    await ensureValidSignatureForOrder(order);

    order.verificationLoading = true;
    order.verificationError = null;
    renderGroups();

    try {
      const data = await requestVerification(order, mode);
      if (data && data.signature && data.signature !== 'valid') {
        console.warn('[CSFX][Signature][REST]', order.orderNumber || order.fileName, data.signature, data);
      }
      order.verification = data;
      order.verification.created_order = !!data.created_order;
      order.verificationError = null;
      if (data && (data.status === 'verified' || data.status === 'verified_with_warnings')) {
        order.status = 'verificado';
      }
      if (data && data.signature) {
        order.signatureStatus = data.signature === 'valid_legacy' ? 'valid' : data.signature;
      }
    } catch (err) {
      console.warn('[CSFX][Verify] fallo', mode, order.orderNumber, err);
      order.verificationError = mode === 'resync'
        ? 'No se pudo ejecutar el resync.'
        : 'No se pudo preparar la verificación.';
      throw err;
    } finally {
      order.verificationLoading = false;
      renderGroups();
      buildSummary();
      if (currentDetailOrderId === order.id) {
        fillDetail(order);
      }
    }
  }

  async function refirmOrder(order){
    if (!order || !order.doc) {
      throw new Error('Pedido sin documento cargado.');
    }
    if (!folder) {
      throw new Error('Selecciona primero la carpeta del día.');
    }
    const fileName = order.fileName || order.pendingFileName;
    if (!fileName) {
      throw new Error('No se pudo determinar el nombre del archivo.');
    }
    let handle = fileHandleMap.get(fileName);
    if (!handle && typeof folder.getFileHandle === 'function') {
      try {
        handle = await folder.getFileHandle(fileName, { create: false });
        if (handle) {
          fileHandleMap.set(fileName, handle);
        }
      } catch (err) {
        throw new Error('No se encontró el archivo en la carpeta seleccionada.');
      }
    }
    if (!handle) {
      throw new Error('No se pudo obtener el handle del archivo.');
    }
    if (typeof handle.requestPermission === 'function') {
      const permission = await handle.requestPermission({ mode: 'readwrite' });
      if (permission !== 'granted') {
        throw new Error('Permiso de escritura denegado.');
      }
    }

    const originalDoc = order.sourceDoc || order.doc;
    const updatedDocLocal = originalDoc ? JSON.parse(JSON.stringify(originalDoc)) : null;
    let updatedDoc = updatedDocLocal || {};
    let serverRefirm = null;

    if (WEB_CRYPTO_AVAILABLE && SIGNATURE_SECRET && updatedDocLocal) {
      await signDocSignature(updatedDoc);
      order.signatureResult = await verifyDocSignature(updatedDoc);
      order.signatureStatus = order.signatureResult.status;
      try {
        serverRefirm = await requestServerSignature(JSON.parse(JSON.stringify(updatedDoc)));
      } catch (err) {
        console.warn('[CSFX][Signature][ReFirm] no se pudo contrastar con el servidor', err);
        if (order.signatureStatus !== 'valid') {
          throw err;
        }
      }

      if (serverRefirm && serverRefirm.signature && serverRefirm.doc) {
        const localSigNode = updatedDoc?.signature;
        const localSig = localSigNode && typeof localSigNode === 'object' ? localSigNode.value : localSigNode;
        if (!timingSafeEqualHex(serverRefirm.signature, localSig || '')) {
          console.warn('[CSFX][Signature][ReFirm] mismatch entre firma local y servidor; usando firma del servidor.', {
            local: localSig,
            server: serverRefirm.signature
          });
          updatedDoc = serverRefirm.doc;
          order.signatureResult = { status: 'valid', source: 'server' };
          order.signatureStatus = 'valid';
        }
      }
    } else {
      const server = await requestServerSignature(updatedDocLocal || JSON.parse(JSON.stringify(order.doc)));
      if (!server || !server.signature || !server.doc) {
        throw new Error('Respuesta inválida al regenerar la firma.');
      }
      updatedDoc = server.doc;
      order.signatureResult = { status: 'valid', source: 'server' };
      order.signatureStatus = 'valid';
    }

    const writable = await handle.createWritable();
    await writable.write(JSON.stringify(updatedDoc, null, 2));
    await writable.close();
    order.doc = updatedDoc;
    order.sourceDoc = updatedDoc;
    renderGroups();
    buildSummary();
    if (currentDetailOrderId === order.id) {
      fillDetail(order);
    }
    alertFriendly(null, 'Firma actualizada correctamente.');
  }

  async function requestVerification(order, mode = 'verify'){
    if (!order) throw new Error('Pedido no disponible');
    await ensureRestContext();
    const endpoint = mode === 'resync' ? 'resync-order' : 'verify-order';
    const url = `${REST_BASE}/${endpoint}`;
    const sourceDoc = order.sourceDoc || order.doc || null;
    const docPayload = sourceDoc ? JSON.parse(JSON.stringify(sourceDoc)) : null;
    const payload = {
      orderNumber: order.orderNumber || order.sourceDoc?.orderNumber || order.doc?.orderNumber || null,
      orderId: order.orderId || order.sourceDoc?.orderId || order.doc?.orderId || null,
      doc: docPayload,
      addNote: true
    };

    const send = async (nonce) => {
      const headers = {
        'Content-Type': 'application/json'
      };
      if (nonce) headers['X-WP-Nonce'] = nonce;
      return fetch(url, {
        method: 'POST',
        credentials: 'include',
        headers,
        body: JSON.stringify(payload)
      });
    };

    let response = await send(restContext.nonce);
    if (response.status === 401) {
      restContext.nonce = null;
      await ensureRestContext(true);
      response = await send(restContext.nonce);
    }

    let data = {};
    try {
      data = await response.json();
    } catch (err) {
      data = {};
    }

    if (!response.ok) {
      const message = data && data.message ? data.message : 'Error de verificación';
      throw new Error(message);
    }

    return data;
  }

  async function requestServerSignature(doc){
    await ensureRestContext();
    const endpoint = 'signature';
    const url = `${REST_BASE}/${endpoint}`;
    const payload = { doc };

    const send = async (nonce) => {
      const headers = {
        'Content-Type': 'application/json'
      };
      if (nonce) headers['X-WP-Nonce'] = nonce;
      return fetch(url, {
        method: 'POST',
        credentials: 'include',
        headers,
        body: JSON.stringify(payload)
      });
    };

    let response = await send(restContext.nonce);
    if (response.status === 401) {
      restContext.nonce = null;
      await ensureRestContext(true);
      response = await send(restContext.nonce);
    }

    let data = {};
    try {
      data = await response.json();
    } catch (err) {
      data = {};
    }

    if (!response.ok) {
      const message = data && data.message ? data.message : 'No se pudo regenerar la firma.';
      throw new Error(message);
    }

    return data;
  }

  function renderGroups(){
    const container = $('#orders');
    container.innerHTML='';
    const grouped = new Map();
    orders.forEach(o=>{
      if(!grouped.has(o.cashier)) grouped.set(o.cashier, []);
      grouped.get(o.cashier).push(o);
    });

    [...grouped.entries()].sort((a,b)=>a[0].localeCompare(b[0])).forEach(([cashier,list])=>{
      list.sort((a,b)=>{
        const ca = (a.createdAtParts?.H||'')+(a.createdAtParts?.M||'')+(a.createdAtParts?.S||'');
        const cb = (b.createdAtParts?.H||'')+(b.createdAtParts?.M||'')+(b.createdAtParts?.S||'');
        return ca.localeCompare(cb);
      });
      const block=document.createElement('div');
      block.className='cashier-block';
      const total = list.reduce((acc,o)=>acc+toAmount(o.total),0);
      const summaryMethods = new Map();
      list.forEach(order => {
        order.payments.forEach(p => {
          const key = p.label || 'Pago';
          const bucket = summaryMethods.get(key) || { amount: 0, change: 0 };
          bucket.amount += toAmount(p.amount);
          bucket.change += toAmount(p.change);
          summaryMethods.set(key, bucket);
        });
      });

      const methodsSummary = summaryMethods.size
        ? [...summaryMethods.entries()]
            .map(([method, val]) => `<span class="summary-chip">${method}: ${fmtMoney(val.amount)}${val.change > 0 ? ` (Vuelto: ${fmtMoney(val.change)})` : ''}</span>`)
            .join('')
        : '<span class="summary-chip">—</span>';

      block.innerHTML = `
        <div class="cashier-header">
          <h3>${cashier}</h3>
          <span class="badge">Órdenes: ${list.length} · Total: ${fmtMoney(total)}</span>
        </div>
        <div class="cashier-summary"><strong>Pagos</strong><div class="payments-summary">${methodsSummary}</div></div>`;

      const table=document.createElement('table');
      table.className='list-table';
      table.innerHTML = `<thead><tr>
        <th>Factura</th>
        <th>Cliente</th>
        <th>Total</th>
        <th>Métodos de pago</th>
        <th>Hora</th>
        <th>Status</th>
        <th>Acciones</th>
      </tr></thead>`;
      const tbody=document.createElement('tbody');
      list.forEach(o=>{
        const tr=document.createElement('tr');
        const paymentsHtml = o.payments.length
          ? `<div class="payments-wrap">${o.payments.map(p=>{
              const changeSnippet = p.change > 0 ? `<small>Vuelto: ${safe(p.changeDisplay)}</small>` : '';
              return `<span class="pay-pill"><strong>${safe(p.label)}</strong><span>${safe(p.display)}</span>${changeSnippet}</span>`;
            }).join('')}</div>`
          : '<span class="muted">—</span>';
        const createdAtLocale = o.createdAtTime || '—';
        const statusHtml = buildStatusHtml(o);
        const verificationMeta = getVerificationMeta(o);
        const verifyDisabled = o.verificationLoading || verifyAllRunning;
        const verifyBtnLabel = o.verificationLoading ? 'Verificando…' : (o.verification && o.verification.status && o.verification.status !== 'missing' ? 'Reverificar' : 'Verificar');
        const verifyBtnDisabledAttr = verifyDisabled ? 'disabled' : '';
        const resyncNeeded = verificationMeta.status === 'missing';
        const resyncBtnDisabledAttr = verifyDisabled ? 'disabled' : '';
        const resyncButton = resyncNeeded ? `<button class="action-btn btn-verify action-resync" data-id="${o.id}" data-action="resync" ${resyncBtnDisabledAttr}>${o.verificationLoading ? 'Resync…' : 'Re-sync'}</button>` : '';
        const adminButton = (o.verification && o.verification.adminUrl) ? `<button class="action-btn btn-view action-admin" data-id="${o.id}" data-action="open-order">Woo</button>` : '';
        const needsRefirm = o.signatureStatus && o.signatureStatus !== 'valid';
        const refirmDisabledAttr = verifyDisabled ? 'disabled' : '';
        const refirmButton = needsRefirm ? `<button class="action-btn btn-verify action-refirm" data-id="${o.id}" data-action="refirm" ${refirmDisabledAttr}>Re-firmar</button>` : '';
        const laybuyBadge = o.laybuyPending ? '<span class="laybuy-pill">LayBuy</span>' : '';
        tr.innerHTML = `
          <td>${safe(o.orderNumber)}</td>
          <td>${safe(o.customerName)} ${laybuyBadge}</td>
          <td>${safe(o.totalDisplay)}</td>
          <td>${paymentsHtml}</td>
          <td>${safe(createdAtLocale)}</td>
          <td>${statusHtml}</td>
          <td class="actions-cell">
            <button class="action-btn btn-view" data-id="${o.id}" data-action="detail">Detalle</button>
            <button class="action-btn btn-verify action-verify" data-id="${o.id}" data-action="verify" ${verifyBtnDisabledAttr}>${verifyBtnLabel}</button>
            ${resyncButton}
            ${refirmButton}
            ${adminButton}
          </td>`;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      block.appendChild(table);
      container.appendChild(block);
    });
  }

  function fillDetail(order){
    const detail = $('#detail');
    const info = $('#detail-info');
    const totals = $('#detail-totals');
    const itemsTable = $('#detail-items tbody');
    const payTable = $('#detail-payments tbody');
    const raw = $('#detail-raw');
    const verifySection = $('#detail-verify-section');
    const verifyBox = $('#detail-verify');

    currentDetailOrderId = order.id;

    if (verifySection && verifyBox) {
      const meta = getVerificationMeta(order);
      if (meta.status === 'pending' && !order.verification && !order.verificationError) {
        verifySection.setAttribute('hidden', '');
        verifyBox.innerHTML = '';
        verifyBox.className = '';
      } else {
        verifySection.removeAttribute('hidden');
        let className = 'is-warning';
        if (meta.status === 'verified') className = 'is-ok';
        else if (meta.status === 'verified_with_warnings') className = 'is-warning';
        else if (meta.status === 'missing') className = 'is-missing';
        else if (meta.status === 'mismatch' || meta.status === 'error') className = 'is-error';
        else if (meta.status === 'loading') className = 'is-warning';
        verifyBox.className = className;
        const parts = [`<div class="verify-label">${safe(meta.label)}</div>`];
        if (meta.message) {
          parts.push(`<div>${safe(meta.message)}</div>`);
        }
        if (Array.isArray(meta.differences) && meta.differences.length) {
          parts.push(renderNoteList(meta.differences));
        }
        if (Array.isArray(meta.warnings) && meta.warnings.length) {
          parts.push(renderNoteList(meta.warnings));
        }
        if (order.verification && order.verification.note_added) {
          parts.push('<div>Nota agregada en WooCommerce.</div>');
        }
        if (order.verification && order.verification.resync_note) {
          parts.push('<div>Resync registrado en WooCommerce.</div>');
        }
        if (meta.adminUrl) {
          parts.push(`<div><a href="${meta.adminUrl}" target="_blank" rel="noopener">Abrir en WooCommerce</a></div>`);
        }
        if (order.verificationError && meta.status === 'error') {
          parts.push(`<div>${safe(order.verificationError)}</div>`);
        }
        verifyBox.innerHTML = parts.join('');
      }
    }

    const infoPairs = [
      ['Factura', order.orderNumber || '—'],
      ['Fecha', (order.createdAtDisplay || order.createdAt) || '—'],
      ['ID interno', order.orderId ?? '—'],
      ['Cajero', order.cashier],
      ['Caja / Registro', order.registerName || '—'],
      ['Cliente', order.customerName || 'Sin cliente'],
      ['Total', order.totalDisplay || fmtMoney(order.total)],
      ['Descuento general', order.discountDisplay || fmtMoney(order.discountAmount)],
      ['Status verificación', getVerificationMeta(order).label || 'Sin sinc.'],
      ['LayBuy', order.laybuyPending ? 'Sí (pendiente de pago)' : 'No'],
      ['Status POS', order.docStatus || '—'],
      ['Firma HMAC', signatureStatusLabel(order.signatureStatus)],
      ['Nota', order.orderData?.note || '—'],
      ['Archivo', order.fileName || '—']
    ];
    info.innerHTML = infoPairs.map(([label,value])=>`
      <div class="info-card">
        <span class="info-label">${label}</span>
        <span class="info-value">${safe(value)}</span>
      </div>
    `).join('');

    const items = Array.isArray(order.orderData?.items)
      ? order.orderData.items
      : Array.isArray(order.doc?.cart?.items)
        ? order.doc.cart.items
        : Array.isArray(order.doc?.cart)
          ? order.doc.cart
          : [];
    itemsTable.innerHTML='';
    if (items.length){
      items.forEach(item=>{
        const tr=document.createElement('tr');
        const productName = item.name || item.product?.name || 'Producto';
        const sku = item.product?.sku || item.barcode || '';
        const qty = item.qty ?? item.quantity ?? 0;
        const price = item.final_price ?? item.price ?? item.price_incl_tax ?? item.total;
        const priceFormatted = item.final_price_currency_formatted || item.price_currency_formatted || fmtMoney(price);
        const total = item.total ?? item.total_incl_tax ?? (Number(price)*Number(qty));
        const totalFormatted = item.total_currency_formatted || item.total_incl_tax_currency_formatted || fmtMoney(total);
        const discount = toAmount(item.final_discount_amount ?? item.discount_amount ?? item.discount ?? 0);
        const discountFormatted =
          item.final_discount_amount_currency_formatted ||
          item.discount_amount_currency_formatted ||
          (discount ? fmtMoney(discount) : '0,00');
        tr.innerHTML = `<td>${safe(productName)}</td><td>${safe(sku)}</td><td>${safe(qty)}</td><td>${safe(priceFormatted)}</td><td>${safe(discountFormatted)}</td><td>${safe(totalFormatted)}</td>`;
        itemsTable.appendChild(tr);
      });
    } else {
      const tr=document.createElement('tr');
      tr.innerHTML = '<td colspan="6" class="muted">Sin productos</td>';
      itemsTable.appendChild(tr);
    }

    payTable.innerHTML='';
    if (order.payments.length){
      const seen = new Set();
      order.payments.forEach(p=>{
        const key = `${p.label}|${p.display}|${p.changeDisplay}|${p.reference}|${p.type}`;
        if(seen.has(key)) return;
        seen.add(key);
        const tr=document.createElement('tr');
        tr.innerHTML = `<td>${safe(p.label)}</td><td>${safe(p.display)}</td><td>${safe(p.changeDisplay || '0,00')}</td><td>${safe(p.reference)}</td><td>${safe(p.type)}</td>`;
        payTable.appendChild(tr);
      });
    } else {
      const tr=document.createElement('tr');
      tr.innerHTML = '<td colspan="5" class="muted">Sin pagos registrados</td>';
      payTable.appendChild(tr);
    }

    totals.innerHTML='';
    const totalsObj = order.totals || {};
    const totalsPairs = [
      ['Subtotal', totalsObj.sub_total ?? order.orderData?.sub_total, totalsObj.currency?.sub_total],
      ['Impuestos', totalsObj.tax_amount ?? order.orderData?.tax_amount, totalsObj.currency?.tax_amount],
      ['Descuento', totalsObj.discount_amount ?? order.orderData?.total_discount, totalsObj.currency?.discount_amount],
      ['Total', totalsObj.grand_total ?? order.orderData?.grand_total, totalsObj.currency?.grand_total],
      ['Pagado', totalsObj.total_paid ?? order.orderData?.total_paid, totalsObj.currency?.total_paid],
      ['Saldo', totalsObj.remain_paid ?? order.orderData?.remain_paid, totalsObj.currency?.remain_paid]
    ];
    totalsPairs.forEach(([label,value,currencyFormat])=>{
      const dt=document.createElement('dt'); dt.textContent = label;
      const dd=document.createElement('dd'); dd.textContent = fmtMoney(value, currencyFormat) || '—';
      totals.appendChild(dt); totals.appendChild(dd);
    });

    raw.textContent = JSON.stringify(order.doc, null, 2);
    detail.style.display = 'flex';
    $('#detail').removeAttribute('hidden');
  }

  function hideDetail(){ const d=$('#detail'); d.style.display='none'; d.setAttribute('hidden',''); currentDetailOrderId = null; }

  $('#detail-close').addEventListener('click', hideDetail);
  $('#detail').addEventListener('click', e=>{ if(e.target === $('#detail')) hideDetail(); });

  const ordersContainer = $('#orders');
  ordersContainer.addEventListener('click', async e=>{
    const btn = e.target.closest('button');
    if(!btn) return;
    const id = btn.dataset.id;
    const action = btn.dataset.action || '';
    const order = orders.find(o=>o.id === id);
    if(!order) return;
    if(action === 'detail') {
      fillDetail(order);
      return;
    }
    if(action === 'verify') {
      try {
        await performVerification(order, 'verify');
      } catch (err) {
        alertFriendly(err, 'No se pudo verificar la orden.');
      }
      return;
    }
    if(action === 'resync') {
      try {
        await performVerification(order, 'resync');
      } catch (err) {
        alertFriendly(err, 'No se pudo ejecutar el resync.');
      }
      return;
    }
    if(action === 'refirm') {
      try {
        await refirmOrder(order);
      } catch (err) {
        alertFriendly(err, 'No se pudo actualizar la firma del archivo.');
      }
      return;
    }
    if(action === 'open-order') {
      if (order.verification && order.verification.adminUrl) {
        window.open(order.verification.adminUrl, '_blank', 'noopener');
      }
      return;
    }
  });

  function toCSV(list){
    const head = ['Cajero','Factura','Cliente','Total','Descuento','Métodos de pago','Fecha','Status','Archivo'];
    const lines = [head.join(',')];
    list.forEach(o=>{
      const payments = o.payments.map(p=>`${p.label} ${p.display}`).join(' | ');
      const statusLabel = getVerificationMeta(o).label || 'Sin sinc.';
      lines.push([
        o.cashier,
        o.orderNumber,
        o.customerName,
        o.totalDisplay || fmtMoney(o.total),
        o.discountDisplay || fmtMoney(o.discountAmount),
        payments,
        o.createdAtDisplay || o.createdAt,
        statusLabel,
        o.fileName
      ].map(v=>`"${String(v??'').replaceAll('"','""')}"`).join(','));
    });
    return lines.join('\n');
  }

  async function pickFolder(){
    if(!('showDirectoryPicker' in window)){
      alert('Tu navegador no soporta File System Access. Usa Chrome/Edge en desktop.');
      return;
    }
    try{
      folder = await showDirectoryPicker({mode:'readwrite'});
      const folderLabel = folder.name || '(día)';
      $('#info').textContent = 'Carpeta: ' + folderLabel + ' (cargando…)';
      orders = [];
      verifyAllRunning = false;
      fileHandleMap.clear();
      buildSummary();
      renderGroups();
      $('#orders').innerHTML = '<p class="muted">Cargando órdenes…</p>';

      const entries = [];
      for await (const entry of folder.values()){
        if(entry.kind!=='file' || !entry.name.endsWith('.json')) continue;
        fileHandleMap.set(entry.name, entry);
        entries.push(entry);
      }

      const loadedOrders = [];
      const coreHint = (typeof navigator !== 'undefined' && Number.isFinite(navigator.hardwareConcurrency))
        ? navigator.hardwareConcurrency
        : 4;
      const maxWorkers = Math.min(8, Math.max(2, coreHint || 4));
      let cursor = 0;

      const getNextEntry = () => {
        if (cursor >= entries.length) return null;
        const entry = entries[cursor];
        cursor += 1;
        return entry;
      };

      const processEntry = async (entry) => {
        try{
          const file = await entry.getFile();
          const txt = await file.text();
          let docOriginal=null; try{docOriginal=JSON.parse(txt);}catch(e){return;}
          let signatureResult={ status: WEB_CRYPTO_AVAILABLE ? 'missing' : 'unchecked' };
          try {
            signatureResult = await verifyDocSignature(docOriginal);
            if (signatureResult && signatureResult.status && signatureResult.status !== 'valid') {
              console.warn('[CSFX][Signature][Folder]', entry.name, signatureResult);
              if (WEB_CRYPTO_AVAILABLE && requestServerSignature) {
                try {
                  const refreshed = await requestServerSignature(JSON.parse(JSON.stringify(docOriginal)));
                  if (refreshed && refreshed.doc && refreshed.signature) {
                    docOriginal = refreshed.doc;
                    signatureResult = { status: 'valid', source: 'server' };
                    try {
                      const writable = await entry.createWritable();
                      await writable.write(JSON.stringify(docOriginal, null, 2));
                      await writable.close();
                    } catch (err) {
                      console.warn('[CSFX][Folder] no se pudo actualizar archivo firmado', entry.name, err);
                    }
                  }
                } catch (err) {
                  console.warn('[CSFX][Signature][Folder] no se pudo regenerar', entry.name, err);
                }
              }
            }
          } catch (err) {
            console.warn('[CSFX][Verify] No se pudo validar firma', entry.name, err);
          }
          const fallbackFileName = (docOriginal && typeof docOriginal === 'object' && docOriginal.fileName) ? docOriginal.fileName : entry.name;
          try{
            const order = normalizeOrder(docOriginal, signatureResult);
            if (!order.fileName) order.fileName = fallbackFileName;
            if (!order.pendingFileName) order.pendingFileName = fallbackFileName;
            order.doc = docOriginal;
            order.sourceDoc = docOriginal;
            loadedOrders.push(order);
          }catch(err){
            console.warn('No se pudo normalizar archivo', entry.name, err);
          }
        }catch(err){
          console.warn('No se pudo leer archivo', entry.name, err);
        }
      };

      const workerTotal = Math.min(maxWorkers, Math.max(entries.length, 1));
      const workers = Array.from({length: workerTotal}, () => (async function run(){
        while (true){
          const entry = getNextEntry();
          if (!entry) break;
          await processEntry(entry);
        }
      })());
      await Promise.all(workers);

      loadedOrders.sort((a, b) => {
        const aKey = (a.createdAtISO || a.createdAt || '') + (a.orderNumber || '');
        const bKey = (b.createdAtISO || b.createdAt || '') + (b.orderNumber || '');
        return aKey.localeCompare(bKey);
      });

      orders = loadedOrders;
      buildSummary();
      renderGroups();
      $('#info').textContent = 'Carpeta: ' + folderLabel;
    }catch(e){
      console.warn(e); folder=null;
      $('#info').textContent = 'Sin carpeta';
    }
  }

  $('#open').onclick = pickFolder;
  $('#export').onclick = ()=>{
    const csv = toCSV(orders);
    const a=document.createElement('a');
    a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
    a.download='csfx_cierre_'+new Date().toISOString().slice(0,10)+'.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{URL.revokeObjectURL(a.href); a.remove()}, 600);
  };
  $('#print').onclick = ()=>window.print();

  const verifyAllButton = $('#verify-all');
  if (verifyAllButton) {
    verifyAllButton.addEventListener('click', async ()=>{
      if (!orders.length || verifyAllRunning) return;
      verifyAllRunning = true;
      buildSummary();
      try {
        try {
          await ensureRestContext();
        } catch (err) {
          alertFriendly(err, 'No se pudo preparar la verificación.');
          return;
        }
        for (const order of orders) {
          try {
            await performVerification(order, 'verify');
          } catch (err) {
            console.warn('Verificación fallida', order.orderNumber, err);
          }
        }
      } finally {
        verifyAllRunning = false;
        buildSummary();
      }
    });
  }
})();
</script>
</body>
</html>
